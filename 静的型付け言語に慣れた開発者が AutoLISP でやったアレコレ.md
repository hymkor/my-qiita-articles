---
title: 静的型付け言語に慣れた開発者が AutoLISP でやったアレコレ
tags: lisp AutoLISP AutoCAD BricsCAD
author: zetamatta
slide: false
---
<dl><dt>(2018.06.02)</dt>
<dd>「静的型付け言語に慣れた開発者が貧弱なCAD用 Lispでやったアレコレ」からタイトル変更しました</dd></dl>


静的型付け言語になれた身としては、欲しい機能がいろいろなくて、つらたにえん。せめて、CommonLisp だったら、もうちょっと楽なんだろうなぁ（使ったことないけど）

(let) がない
============
ローカル変数は使えるが、宣言できる場所が `(defun)` の直後だけというのはつらい。もっと使う場所の近くで、狭い有効範囲をきって使いたい。普通は`(let)`を使うところだが、CAD系Lispには`(let)`がない。仕方ないので`((lambda (/ 変数リスト) … ))` で代用するようにした（というのが下記の記事）

* [let のない Lisp処理系で lambda を let のかわりにつかう - Qiita](https://qiita.com/zetamatta/items/578c1eb46c38ba4d2ded)

early-return がない
===================
他の言語だと、エラーの場合早々に return するのがよいとされているが、CAD用Lispには return 文的なものがない。結果、関数の頭で、エラーチェックをたくさんする時、以下のような問題がある。

* `(if)` でエラーチェックすると、正常系のコードが else句の奥底のすごく深いインデントになってしまう
* `(quit)` でアプリケーションを終了すると、finally 的処理が呼ばれない（エラートラップ等でひと工夫すればできなくもないが、仕組みが大層）

`(cond)` を使うようにすれば、エラーケースがたくさんあっても、あまりインデントは深くならない（ただ、エラー条件が複雑になると、うまく書けない時も多い）

```lisp
(cond
  ((エラー条件１)
   エラー処理１
  )
  ((エラー条件２)
    エラー処理２
  )
  ; 中略
  ((エラー条件Ｎ)
    エラー処理Ｎ)
  (T
     正常系処理
  )
```

グローバル変数をうっかり壊してしまう
================================

Perl でいうところの use strict が欲しい。なければ作ればよいのだ。

* [zetamatta/strict-lsp: strict.lsp - variables checker for CAD's Lisp](https://github.com/zetamatta/strict-lsp)

ソースファイルをS式として読み込んで、`(defun)`の中身を解析し、未使用の変数や、逆に宣言漏れがあったら、コマンドラインにリポートする。

名前空間がない
=============
いろいろ `(load)` していると関数名が被ることが懸念される。といっても名前空間がないので、

* グローバルな名前には接頭語をつける（ありがち）
    * foo.lsp ならば `(defun foo-xxxx …)`
* 関数内関数で済むなら、それですませる（その関数名はローカルで）

といった方向で誤魔化す。

以上

